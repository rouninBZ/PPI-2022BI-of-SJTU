Bellman-Ford Algorithm是针对于传统路径生成方法中，由于“负权边的存在，无法很好发挥作用的问题所创造的一种算法。

其特点为，所有候补节点并非平权，在选择可能路径上有一定的倾向性。但最终所有路径都会遍历，同DijA相比，时间复杂度会略高一些，但不会出现由于负权边导致的错误答案等问题。

其具体实现方法为，

![image-20220618143833647](C:\Users\Thunoerobot\AppData\Roaming\Typora\typora-user-images\image-20220618143833647.png)

先将除了起点外的所有顶点“分数”设置为无穷大，之后从起点开始，向四周所有邻接顶点进行更新打分。比如，对B而言，新的打分为A的分数加上边的权值。

![image-20220618144026595](C:\Users\Thunoerobot\AppData\Roaming\Typora\typora-user-images\image-20220618144026595.png)

对于A的临界顶点更新完毕。此时对于还未更新的BC两个顶点，选择分数更小的C开始更新。B本身的分数为9，而从C更新过去的权值为6+2=8，比9更小，所以B的打分更新为8。

就这样更新，直到所有顶点都进行了更新操作。最终根据终点的分数，可以得到最短路径。

（图片来自石田　保輝（いしだ　もりてる）　宮崎　修一(みやざき しゅいち)）

若网络中，顶点数为n，边数为m；针对每个顶点都进行一轮更新，每次更新复杂度为O(m)，一共需要更新n次，那么算法复杂度为O(mn).

但要注意，无论在更为鲁棒的BFA中，还是在其他算法中，对于输入的图网络都要保证一点，即所有边权的加和不应小于0，否则最终会进入死循环，无法给出合适的结果。一个简单的例子是，针对各边权均为负数的哈密顿回路，每次循环，都会使路径长度变短，最终会得到“在回路中循环无数遍，即为最短路径”这种明显不合适的结论。
