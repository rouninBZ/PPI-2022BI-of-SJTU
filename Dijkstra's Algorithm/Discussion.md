Dijkstra算法优化

通过观察数据，我们发现，在顶点很多的无向图中，边却很少，如果我们还是利用邻接矩阵来实现图的存储的话那么会占用大量内存，这样是我们不愿看到的，那么我们如果可以存储边来抽象表示我们的无向图，因为我们只需要对较少的边进行运算即可。

这里我们会应用了**链式前向星**进行优化

使用这种优化的前提就是：实际边远小于无向图的最大边数。

前向星是一种数据结构，以存储边的方式来存储图。构造方法如下：读入每条边的信息，将边存放在数组中，把数组中的边按照起点顺序排序。通常用在点的数目太多，或两点之间有多条弧的时候。除了不能直接用起点终点定位以外，前向星几乎是完美的。

```c
struct edge{
    int start;//边的起点
    int to;//边的终点
    int w;//边的权值。
}q[10001];
//起点就是在边的序号，所以我们读入之后要按起点顺序进行排序。
```

这种方法有种弊端，就是边与边的关系没有联立起来，尤其在我们的Dijkstra算法中就是根据同一点的边进行拓展的，所以在这基础上我们推出了链式前向星，这种就可以根据起点来进行组合，形成跟邻接表一样的效果，但比邻接表要简单的多。

```c
typedef struct Edge{
	int next;//边起点相同的第一条边的编号。
	int to; //边的终点顶点编号。
	int w;//边权值
}Edge;
Edge edge[M];//M为边的最大值。
int head[maxn];//maxn为顶点的最大值。对于head[i]来说：存储以i为起点的第一条边的编号。记住是第一条边。我们一般都要初始化head数组为-1，即不存在第一条边。
```

**这个核心就是利用head数组和边集合中的next来联立的，第一条边的上一条边永远是-1**，这在之后整个的代码实现中会看到。我们存储好边之后，就可以开始我们的关键Dijkstra算法的实现了，还是以贪心的思想去实现。









总结与思考

不足之处：我们发现在Dijkstra算法中，总是要寻找当前的最短的最短路径，这是需要时间来查找的，但如果我们利用优先队列的自动排序的功能，即用堆实现这个功能，在每一趟中选择队头元素，这就是我们想要的最短路径的相关信息，也就是这样我们就可以不用去查找了。但是由于优先队列需要C++知识，所以project中并未实现